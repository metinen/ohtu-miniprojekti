/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Vinkkitietokanta;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;


/**
 * Tämä hoitaa tiedon muokkaamisen oikeanlaiseksi niin tietokannalle, kuin
 * tietokannasta.
 */

/*MI/24.11.2017 Tauluissa Vinkki, Kirja, Podcast, Video ja Kirjoittaja on päällä juokseva id numerointi kun tauluun lisää rivin.
Dumppaan tähän Sprint2:een tarvittavat SQL-komennot liittyen lisäämiseen, poistamiseen ja listaukseen!:
(Eivät ole parametrisoituja tarkoituksella, siitä taisi olla Timolla taski):

Listaus, (käyttöliittymässä on valittu haetun tyyppi(KIRJA,PODCAST TAI VIDEO), kaikki sarakkeet:
................................................................................................
Huom. en ole varma monesta moneen suhteen kohdalla( Kirja ja Kirjoittaja) minkälainen listaus sql:sta pitää ottaa ulos. Esimerkki-
datassa siis kirjalla "Toinen kirja "on kaksi kirjoittajaa. Eli olkaapa yhtedessä jos ilmenee että tämä väärä. 

SELECT  *  FROM Kirja, Kirjoittaja, KirjaKirjoittaja WHERE Kirja.kirja_id=KirjaKirjoittaja.kirja AND
 Kirjoittaja.kirjoittaja_id=KirjaKirjoittaja.kirjoittaja;
Antaa tulosteen:
1|99999|Eka kirjani|Tosi hyvä kirja|1|1|Ilvonen|Maria|1|1
2|9969|Toinen kirja|Tämäkin tosi hyvä kirja|2|2|Virtanen|Ville|2|2
2|9969|Toinen kirja|Tämäkin tosi hyvä kirja|2|3|Virtanen|Minttu|2|3  

Listaus, KAIKKI: kirjoittaja, otsikko, isbn/url/nimi, luettu vai ei
....................................................................................................................
Select kirja.otsikko, kirja.isbn, vinkki.luettu FROM Vinkki, Kirja WHERE vinkki_id=vinkki UNION Select video.otsikko, video.url, vinkki.luettu FROM Vinkki, Video
 WHERE vinkki_id=vinkki UNION Select podcast.otsikko, podcast.nimi, vinkki.luettu FROM Podcast, Vinkki WHERE vinkki_id=vinkki;

// koska olen käyttänyt Unionia, en voinut tehdä kyselyä select *, koska jokaisessa joukossa pitää olla samanverran sarakkeita ja noissa kolmeassa taulussa ei ole sama

Lisää 
.......

Valittaessa käyttöliittymässä komento "lisää" tapahtuu:
INSERT INTO Vinkki (luettu) VALUES ('');
HUOM!!! SQLite ei tue TRUE/FALSE-tyylistä joten vaikka luettu on boolean, tietokannassa 
sen arvot ovat joko 0 eli false tai 1 eli true.

Sitten Käyttöliittymä kysyy lukuvinkin tyyppiä

Jos kirja tai podcast,
Käyttöliittymä kysyy kirjoittajan tai kirjoittajien etunimeä ja sukunimeä:
INSERT INTO Kirjoittaja (etunimi,sukunimi) VALUES ('','');
INSERT INTO VinkkiKirjoittaja (vinkki,kirjoittaja) VALUES ('','');
  
Tämän jälkeen/suoraan tähän jos video: Käyttöliittymän mukaisesti lisäkysymyksiä ja sen perusteella SQL-lisäyskomennot:

INSERT INTO Kirja (isbn,otsikko,kuvaus,vinkki) VALUES ('','','','');

INSERT INTO Video (otsikko,url, vinkki) VALUES (); 

INSERT INTO Podcast (isbn,otsikko,kuvaus,vinkki) VALUES ();



Poista, käyttöliittymä kysynyt mikä tyyppi (Kirja, video tai podcast) ja otsikko
.................................................................................
Tämä on tosi rumasti tehty mutta sprintin aika loppui kesken tutkimisen ja halusin tämä toimimaan edes jotenkuten. Cascade-toiminto ei toimi lainkaan, ks. 
lisää konstruktorin kommentissa. Jos jollain riittää aika saa laittaa paremmaksi!! Mielestäni sprint2 voisi jättää tekemättä

SELECT kirja_id FROM Kirja WHERE otsikko= 'jokuotsikko';
-> palauttaa esim.2 
DELETE FROM Vinkki WHERE vinkki_id='2'; //esimerkkiarvo
DELETE FROM Kirja WHERE kirja_id= '2';

Koodin joku if lause tyylinen
Jos Select 

SELECT kirjoittaja FROM VinkkiKirjoittaja WHERE vinkki='2';
-> palauttaa esim.5
DELETE FROM Kirjoittaja WHERE kirjoittaja_id= '5'; 
DELETR FROM VinkkiKirjoittaja  WHERE kirjoittaja= '5';

SELECT video_id FROM Video WHERE otsikko= 'jokuotsikko';
-> palauttaa esim.2
DELETE FROM Vinkki WHERE vinkki_id='2'; //esimerkkiarvo
DELETE FROM Video WHERE kirja_id= '2';


SELECT podcast_id FROM Podcast WHERE otsikko= 'jokuotsikko';
-> palauttaa esim.2
DELETE FROM Vinkki WHERE vinkki_id='2';
DELETE FROM Podcast WHERE podcast_id= '2';
SELECT kirjoittaja FROM VinkkiKirjoittaja WHERE vinkki='2';
-> palauttaa esim.5
DELETE FROM Kirjoittaja WHERE kirjoittaja_id= '5';
DELETR FROM VinkkiKirjoittaja  WHERE kirjoittaja= '5';
 
*/



public class Vinkkitietokanta implements VinkkitietokantaRajapinta {

    Connection conn = null;
    Statement stmt = null;
     
    public Vinkkitietokanta(String tkPath){
        //Liitä tietokanta        
        try{

	/*MI/23.11 Tämä osa kommentoitu pois ainakin sprint 2 kohdalla.
	SQLitessa silleen että vaikka on ON DELETE CASCADE viiteavainten kohdalla niin joku viiteavainsupport ei ole oletuksena päällä
	 eikä CASCADE siis oikeasti toimi suoraan: foreign keys pitää ensin laittaa päälle.
	Noh, kun laitoin tämän viiteavainsupportin päälle (suoraan tietokannassa, allaolevassa koodissa oli ajatuksena että
	sama tehdään koodillisesti aina kun tietokantayhteys avataan) niin vinkin poistaminen ei toiminut lainkaan oikein. Siksi vastaava koodi alla ei käytössä
	 enkä ehdi sprint2 kohdalla tutkia enempää.
	Siksi poistaminen on tällä hetkellä niin manuaalista eli pitää käydä joka taulussa poistamassa tietoja,
	koodi täältä: http://code-know-how.blogspot.fi/2011/10/how-to-enable-foreign-keys-in-sqlite3.html				
	 SQLiteConfig config = new SQLiteConfig();  
         config.enforceForeignKeys(true);*/

            conn=DriverManager.getConnection(tkPath);
            //System.out.println("tietokanta liitetty");
            stmt = conn.createStatement();            
            //System.out.println("statement luotu");
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
    }
    
    
    //Sulje yhteydet tietokantaan
    public void sulje(){
        try{
        if(stmt!=null)
            conn.close();
        }catch(SQLException se){
        }
        try{
           if(conn!=null)
              conn.close();
        }catch(SQLException se){
           se.printStackTrace();
        }
    }
    
    //Tallentuuko suoraan vai pitääkö erikseen kutsua jotain tallenna tietokanta?
    private void tallennaTietokanta(){    
    }
    
    public boolean tietokantaliitetty(){
        if(conn==null) return false;
        return true;
    }

    @Override
    public boolean poistaKirja(String otsikko) {
        //Toivotaan, että syöte on kunnollista
        //DELETE FROM vinkki where otsikko = 'surkea päivä'   
        try{
            String sql = "DELETE FROM vinkki where otsikko = '"+otsikko+"'";
            stmt.executeUpdate(sql);
        }catch(SQLException se){
            se.printStackTrace();
        }
        //Kirjan poistaminen antaa nyt aina true:n tarvitaan joku
        //tapa tarkistaa, että onnistuuko poisto todella
        return true;
    }

    @Override
    public boolean lisaaKirja(String kirjoittaja, String otsikko) {
        //INSERT INTO vinkki VALUES ('hermanni', 'surkea päivä', 'kirja')
        //Toivotaan, että syöte on kunnollista
        try{
            String sql = "INSERT INTO vinkki VALUES ('"+kirjoittaja+"','"+otsikko+"', 'kirja')";
            stmt.executeUpdate(sql);
        }catch(SQLException se){
            System.out.println(se.toString());
        }
        //Kirjan lisääminen antaa nyt aina true:n tarvitaan joku
        //tapa tarkistaa, että onnistuuko poisto todella
        return true;
    }

    @Override
    public List<String> haeKaikkiString() {
        List<String> lista = new ArrayList<>();
        try{
            String sql = "SELECT * FROM Vinkki";
            ResultSet rs = stmt.executeQuery(sql);
            while(rs.next()){
                String kirjoittaja  = rs.getString("kirjoittaja");
                String otsikko = rs.getString("otsikko");
                Vinkki vinkki = new Vinkki(kirjoittaja,otsikko);
                lista.add(vinkki.toString());
            }
            rs.close();
        }catch(SQLException se){
            System.out.println(se.toString());
        }
        
        return lista;
        //"SELECT * FROM vinkki"
    }

    @Override
    public List<Vinkki> haeKaikki() {
        //Pasta koodia siivoa joskus 
        List<Vinkki> lista = new ArrayList<>();
        try{
            String sql = "SELECT * FROM vinkki";
            ResultSet rs = stmt.executeQuery(sql);
            while(rs.next()){
                String kirjoittaja  = rs.getString("kirjoittaja");
                String otsikko = rs.getString("otsikko");
                Vinkki vinkki = new Vinkki(kirjoittaja,otsikko);
                lista.add(vinkki);
            }
            rs.close();
        }catch(SQLException se){
            se.printStackTrace();
        }
        return lista;
    }

}
